<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-30T23:05:08+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">苏耀东的博客</title><subtitle>oden的个人博客</subtitle><author><name>Oden Su</name></author><entry><title type="html">Docker小记-Docker Compose</title><link href="http://localhost:4000/2020/05/10/Docker%E5%B0%8F%E8%AE%B0-Docker-Compose/" rel="alternate" type="text/html" title="Docker小记-Docker Compose" /><published>2020-05-10T00:00:00+08:00</published><updated>2020-05-10T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/10/Docker%E5%B0%8F%E8%AE%B0-Docker%20Compose</id><content type="html" xml:base="http://localhost:4000/2020/05/10/Docker%E5%B0%8F%E8%AE%B0-Docker-Compose/">&lt;h2 id=&quot;命令&quot;&gt;命令&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Compose描述完整的环境以及服务组件的交互。一个Compose文件可能会描述四到五个单独的服务，它们都是相互关联的，但应保持隔离和独立伸伸缩。&lt;/li&gt;
  &lt;li&gt;启动：进入创建docker-compose.yml文件的目录并运行以下的命令：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;查看日志(想只看到一个或多个服务,就给出那些服务的命名)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose logs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;列出当前目录下yml文件定义的所有容器
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;清理环境
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose stop 
docker-compose rm -vf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;会删除所有的服务或者一个由环境定义的特定服务。一个小的区别是，-f 选项并不强迫删除正在运行的容器，相反，它会关闭用户确认阶段。-v选项清理卷&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;重新构建环境:当你执行这个命令后，它将停止当前并删除运行的容器，接着创建新的容器，并重新附着前代环境挂载的数据卷，
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;重建一个或所有服务(想只重建一个或多个服务,就给出那些服务的命名)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;拉取环境中不存在的镜像
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose pull
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;构建启动和重新构建服务&quot;&gt;构建、启动和重新构建服务&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;当Compose启动任何特定的服务时，它将启动所有其依赖的服务。&lt;/li&gt;
  &lt;li&gt;当你使用一个未经限定的 docker-compose up 命令时，Compose 将创建或重新创建环境中的每一个服务并启动所有的服务，如果Compose检测到有任何还没构建或者使用了缺失镜像的服务，它会触发一个构建或获取合适的镜像（就像docker run命令）。&lt;/li&gt;
  &lt;li&gt;如果知道一个运行正确的某个特定服务的依赖关系，你可以不需要依赖关系就可以启动或重新启动一个服务。为此，需要引入flag–no-dep。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose up --no-dep -d proxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;服务伸缩和删除&quot;&gt;服务伸缩和删除&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Compose 能够支持服务的纵向伸缩，当这么做时，Compose 创建了提供该服务的容器的多个副本。这些副本将在你缩小规模时会自动清理
使用以下的命令扩展api服务：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose scale api=5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;端口号0为主机的临时端口，当你绑定到端口0时，操作系统将在一个预定义范围内选择一个可用的端口&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;迭代和持久化状态&quot;&gt;迭代和持久化状态&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;当服务重新构建时，附加的管理卷不会被删除。相反，它们重新附加到了那个服务更换后的容器上。这意味着可以自由地迭代而不用担心丢失数据&lt;/li&gt;
  &lt;li&gt;docker-compose rm命令和flag-v删除时，管理卷最后也会被清理了。&lt;/li&gt;
  &lt;li&gt;如果你在 docker-compose.yml 文件中重命名或删除一个服务定义，那么你就失去了使用Compose管理这个服务的能力。重新构建并重启后，新的服务将会工作，而旧服务被孤立。&lt;/li&gt;
  &lt;li&gt;解决方法是直接使用docker命令清理环境或者回到docker-compose.yml文件中添加孤立的服务定义，用Compose清理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;网络和连接问题&quot;&gt;网络和连接问题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Docker构建的镜像是通过创建防火墙规则和注入服务发现信息到所依赖的容器的环境变量和/etc/hosts文件中来建立连接关系&lt;/li&gt;
  &lt;li&gt;在高度迭代的环境中，用户可能只要重启特定的服务，如果另外一个服务依赖于它的话，这可能会导致一些问题。举例来说，如果启动了Coffee API环境，然后选择性地重启coffee服务，proxy服务将不再能够追溯到它的上游依赖。当容器重新创建或者重新启动后，它们返回的是不同的IP地址。这一变化使得注入proxy服务的信息失效了。&lt;/li&gt;
  &lt;li&gt;在没有动态服务发现机制的环境中处理这个问题最好的方法是重启整个环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data:
  image: gliderlabs/alpine
  command: echo Data Container
  user: 999:999
  labels:
    com.dockerinaction.chapter: &quot;11&quot;
    com.dockerinaction.example: &quot;Coffee API&quot;
    com.dockerinaction.role: &quot;Volume Container&quot;

dbstate:
  extends:
    file: docker-compose.yml
    service: data
  volumes:
    - /var/lib/postgresql/data/pgdata

# the postgres image uses gosu to change to the postgres user
db:
  image: postgres
  volumes_from:
    - dbstate
  environment:
    - PGDATA=/var/lib/postgresql/data/pgdata
    - POSTGRES_PASSWORD=development
  labels:
    com.dockerinaction.chapter: &quot;11&quot;
    com.dockerinaction.example: &quot;Coffee API&quot;
    com.dockerinaction.role: &quot;Database&quot;

# the nginx image uses user de-escalation to change to the nginx user
proxy:
  image: nginx
  restart: always
  volumes:
    - ./proxy/app.conf:/etc/nginx/conf.d/app.conf
  ports:
    - &quot;8080:8080&quot;
  links:
    - coffee
  labels:
    com.dockerinaction.chapter: &quot;11&quot;
    com.dockerinaction.example: &quot;Coffee API&quot;
    com.dockerinaction.role: &quot;Load Balancer&quot;

coffee:
  build: ./coffee
  user: 777:777
  restart: always
  expose:
    - 3000
  ports:
    - &quot;0:3000&quot;
  links:
    - db:db
  environment:
    - COFFEEFINDER_DB_URI=postgresql://postgres:development@db:5432/postgres
    - COFFEEFINDER_CONFIG=development
    - SERVICE_NAME=coffee
  labels:
    com.dockerinaction.chapter: &quot;11&quot;
    com.dockerinaction.example: &quot;Coffee API&quot;
    com.dockerinaction.role: &quot;Application Logic&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;build键的值是用于构建的Dockerfile文件所在位置的目录，你可以使用从YAML文件位置开始的相对路径&lt;/li&gt;
  &lt;li&gt;dockerfile键来提供一个备选的Dockerfile文件的名称。&lt;/li&gt;
  &lt;li&gt;environment键可以为一个服务设置环境变量&lt;/li&gt;
  &lt;li&gt;容器元数据可以设置为以 labels 为键，&lt;/li&gt;
  &lt;li&gt;expose键接受容器端口的一个列表，这些端口应该根据防火墙规则公开。&lt;/li&gt;
  &lt;li&gt;ports键按照与docker run命令中-p选项一样的格式接受描述了端口映射关系的字符串列表。&lt;/li&gt;
  &lt;li&gt;links命令按照与docker run命令中flag –link一样的格式接受和定义了链接的列表。&lt;/li&gt;
  &lt;li&gt;proxy服务使用一个卷来绑定挂载一个本地的配置文件到Nginx的动态配置位置，这是一个简单的注入配置而不用构建一个完整的新镜像。&lt;/li&gt;
  &lt;li&gt;db服务使用volumes from键来列出那些定义了必需卷的服务，&lt;/li&gt;
  &lt;li&gt;服务扩展：必须指定文件和被扩展的服务名称，相关的键是extends以及内嵌的file和service。服务扩展工作类似于 Dockerfile 构建的方式。首先构建原型容器，然后提交。子容器是一个由新生成的层构建的新容器。就像Dockerfile构建，这些子容器继承了父容器所有的属性，包括元数据。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">Compose描述完整的环境以及服务组件的交互</summary></entry><entry><title type="html">Docker小记-Dockerfile</title><link href="http://localhost:4000/2020/05/09/Docker%E5%B0%8F%E8%AE%B0-Dockerfile/" rel="alternate" type="text/html" title="Docker小记-Dockerfile" /><published>2020-05-09T00:00:00+08:00</published><updated>2020-05-09T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/09/Docker%E5%B0%8F%E8%AE%B0-Dockerfile</id><content type="html" xml:base="http://localhost:4000/2020/05/09/Docker%E5%B0%8F%E8%AE%B0-Dockerfile/">&lt;h2 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker build构建镜像：
    &lt;ul&gt;
      &lt;li&gt;–tag（或-t）选项的值指定了你想要使用的完整仓库设计。下例中，使用了ubuntu-git:auto。最后的参数则指定了Dockerfile的位置，表示在当前目录寻找文件。&lt;/li&gt;
      &lt;li&gt;docker build 命令还有另外一个选项–file（或-f），这个选项让你能够设置Dockerfile的名字。Dockerfile是默认的文件名字。这个选项只能设置文件的名字，而不能设置文件的位置。最后一个参数是设置位置&lt;/li&gt;
      &lt;li&gt;如果需要完整地从零开始构建，使用–no-cache选项来禁止缓存的使用。但注意，确保完全需要时才禁止缓存。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;例子：在包含Dockerfile文件的目录中使用docker build命令，从Dockerfile文件创建一个新镜像，并将新镜像的标签设为auto
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build -tag ubuntu-git:auto .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;元数据指令&quot;&gt;元数据指令&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM debian：wheezy
MAINTAINER yourName &quot;xx@xx.com&quot;
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y inotify-tools nginx apache2 openssh-server
ENV VERSION=&quot;0.1.1&quot; \   
    APPROOT=&quot;/APP&quot;
LABEL base.version=&quot;${VERSION}&quot;
WORKDIR ${APPROOT}
ADD . ${APPROOT}
ENTRYPOINT [&quot;/app/mailer.sh&quot;]
EXPOSE 33333
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;定义哪些文件永远不应该被复制进镜像中。你可以在名为.dockerignore的文件中指定这些信息。&lt;/li&gt;
  &lt;li&gt;每个 Dockerfile 指令都会导致一个新层被创建。指令应该尽可能合并，这是因为构建程序不会进行任何的优化。&lt;/li&gt;
  &lt;li&gt;FROM指令使得栈从某个镜像顶部开始，任何被构建的新层都会被放置在这个镜像的最上层。&lt;/li&gt;
  &lt;li&gt;MAINTAINER指令设置了镜像元数据Author的值。&lt;/li&gt;
  &lt;li&gt;ENV，类似于docker run或docker create命令的–env选项，ENV指令设置了镜像的环境变量。
    &lt;ul&gt;
      &lt;li&gt;Dockerfile文件中声明的环境变量不仅对产生的镜像有效，它们还能够在其他Dockerfile指令中使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;LABEL 指令用来定义键值对，这些键值对被记录为镜像或容器的额外元数据&lt;/li&gt;
  &lt;li&gt;使用WORKDIR指令指定默认工作目录，当指定的WORKDIR目录不存在，那么这个目录会被自动创建。&lt;/li&gt;
  &lt;li&gt;EXPOSE指令创建了一个层，对外开放端口&lt;/li&gt;
  &lt;li&gt;ENTRYPOINT指令则设置了在容器启动时需要被运行的可执行程序。比如说入口点被设置为exec ./mailer.sh，这使用了该指令的shell格式。
    &lt;ul&gt;
      &lt;li&gt;ENTRYPOINT指令有两种格式：shell格式和exec格式。shell格式类似于一个shell命令，其中的参数以空格为界限分隔开来。exec格式是一个字符串的数组，其中第一个值是要执行的命令，剩下的值则是参数。&lt;/li&gt;
      &lt;li&gt;shell格式指定的命令将会被作为默认shell的一个参数来执行具体点说，指定的命令在运行时会以/bin/sh -c ＇exec ./mailer.sh＇的形式执行。&lt;/li&gt;
      &lt;li&gt;如果ENTRYPOINT使用了shell格式，那么CMD指令提供的所有其他参数，或docker run命令在运行时指定的额外参数都会被忽略。这使得ENTRYPOINT的shell格式不那么灵活可变动了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可以在基础镜像创建用户和用户组账户，然后让具体的实现者在他们完成构建时再设置默认的用户。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;文件系统指令&quot;&gt;文件系统指令&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Dockerfile 定义了三个指令来修改文件系统：COPY、VOLUME和ADD。&lt;/li&gt;
  &lt;li&gt;COPY指令至少需要两个参数。最后一个参数是目的目录，其他所有的参数则为源文件。
    &lt;ul&gt;
      &lt;li&gt;任何被复制的文件的所有权都会被设设置为root用户，因此，最好在所有需要更新的文件都复制到镜像后，再使用RUN指令来修改文件的所有权。&lt;/li&gt;
      &lt;li&gt;COPY指令同样支持shell格式和exec格式。但是如果任何一个参数包含了空格，那么你必须要使用exec格式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VOLUME:在字符串数组参数中的每一个值都会在产生的新层中被创建为一个新的卷定义。在镜像构建时定义卷比在运行时更加受到限制&lt;/li&gt;
  &lt;li&gt;CMD 指令表示入口点的一个参数列表。一个容器的默认入口点是/bin/sh。如果一个容器的入口点没有被设置，这个默认值会被使用。如果入口点被设
设置了，并且使用的是exec格式，那么将使用CMD指令来设置默认参数。&lt;/li&gt;
  &lt;li&gt;ADD指令：如果指定了一个URL，会拉取远程源文件；会将被判定为存档文件的源中的文件提取出来
    &lt;ul&gt;
      &lt;li&gt;使用ADD指令的远程拉取功能并不是一个好的实践。原因在于尽管这个特性非常方便，但是它没有提供任何机制来清理不被使用的文件，这会导致额外的层。作为替代品，你应该使用链状的RUN指令
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &quot;https://bootstrap.pypa.io/get-pie.py&quot; -o &quot;get-pip.py&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;注入下游镜像在构建时发生的操作&quot;&gt;注入下游镜像在构建时发生的操作&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;如果生成的镜像被作为另一个构建的基础基础镜像，则 ONBUILD 指令定义了需要被执行的那些指令&lt;/li&gt;
  &lt;li&gt;上游的 Dockerfile一般会使用类似以下形式的指令：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ONBUILD COPY[“.”,“/var/myapp”]
ONBUILD RUN go build/var/myapp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;跟随在 ONBUILD 后的指令不会在包含它们的 Dockerfile 被构建时被执行。这些指令会被记录在生成镜像的元数据ContainerConfig.OnBuild下。&lt;/li&gt;
  &lt;li&gt;这个元数据会一直被保留，直到生成的镜像被另外的 Dockerfile 作为基础镜像。当一个下游的 Dockerfile 通过 FROM指令使用了上游的镜像（带有ONBUILD指令的Dockerfile产
产生的镜像），那么这些在ONBUILD 后跟随的指令将会在 FROM 指令后，下一条指令前被执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;初始化进程&quot;&gt;初始化进程&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基于UNIX的计算机通常会先启动一个初始化（init）进程。这个init进程负责启动所有其他的系统服务，让它们持续运行，然后负责关闭它们。使用一个 init 风格的系统来启动、管理、重启、关闭容器进程通常是恰当的。&lt;/li&gt;
  &lt;li&gt;使用一个 init 进程是启动多个程序、清理遗弃的进程、监控进程和自动化重启失败进程的最佳方式。&lt;/li&gt;
  &lt;li&gt;轻量级的init程序:主流的选择包括runit、Busybox init、Supervisord和DAEMON工具&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;加固应用镜像&quot;&gt;加固应用镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;加固一个镜像就是塑造镜像，使得基于这个镜像创建的任何Docker容器的攻击面减减少的过程&lt;/li&gt;
  &lt;li&gt;加固应用镜像的一个通用策略就是最小化包含在其中的软件。&lt;/li&gt;
  &lt;li&gt;通用指南就是尽可能地削减特权&lt;/li&gt;
  &lt;li&gt;可以强制基于某个特定的镜像来构建镜像,镜像作者就能够强制从一个特定的，且未改动的起点开始构建。
    &lt;ul&gt;
      &lt;li&gt;在标准的tag位置后面添加一个@符号，符号后面跟随的就是摘要。一旦你拥有了这个摘要，你可以将它作为ID在Dockerfile中的FROM指令中使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;你能够确保无论容器如何基于你的镜像来构建，它们都会拥有一个合适的默认用户
    &lt;ul&gt;
      &lt;li&gt;Dockerfile包含了一个USER指令，和docker run或docker create命令一样，它能够设置用户和用户组。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;你应该去除root用户提权的通用途径&lt;/li&gt;
  &lt;li&gt;SUID和SGID权限:一个设置有 SUID 位的可执行文件总是会以它的所有者用户来执行,会从拥有该程序的用户组的上下文执行，而不是程序所有者。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 将镜像中所有文件的 SUID和SGID权限都去除
RUN for i in $(find/-type f ( -perm +6000 -o -perm +2000 ));
do chmod ug-s $i; done
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">Dockerfile是一个文件，由构建镜像的指令构成。本文介绍使用Dockerfile自动化打包</summary></entry><entry><title type="html">Docker小记-从容器构建镜像</title><link href="http://localhost:4000/2020/05/08/Docker%E5%B0%8F%E8%AE%B0-%E4%BB%8E%E5%AE%B9%E5%99%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/" rel="alternate" type="text/html" title="Docker小记-从容器构建镜像" /><published>2020-05-08T00:00:00+08:00</published><updated>2020-05-08T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/08/Docker%E5%B0%8F%E8%AE%B0-%E4%BB%8E%E5%AE%B9%E5%99%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F</id><content type="html" xml:base="http://localhost:4000/2020/05/08/Docker%E5%B0%8F%E8%AE%B0-%E4%BB%8E%E5%AE%B9%E5%99%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">&lt;h2 id=&quot;从容器构建镜像&quot;&gt;从容器构建镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;步骤：
    &lt;ul&gt;
      &lt;li&gt;根据最终想要的东西包选择一个已存在的镜像来创建一个容器。&lt;/li&gt;
      &lt;li&gt;修改这个容器的文件系统。这些改动会被保存在容器的联合文件系统的新文件层&lt;/li&gt;
      &lt;li&gt;改动完成后将这些改动提交（commit）。一旦改动被提交，你就能够从新镜像创建新的容器了。
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 这条命令会启动一个运行bash shell的新容器。基于这个shell，你就能够输入命令来自定义你的容器了
 docker run -it -name image-dev ubuntu:latest /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker commit old_container_name new_container_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对容器内文件系统的改动都会被写入到新的文件层中，这个文件层归创建它的容器所有。(联合文件系统（UFS）挂载提供了容器的文件系统)&lt;/li&gt;
  &lt;li&gt;Commit创建新镜像：使用-a选项为新镜像指定作者的信息，使用-m选项，设置关于提交的信息&lt;/li&gt;
  &lt;li&gt;启动原始容器时附带的命令会被提交到新镜像中，入口点（entrypoint）是更好的做法&lt;/li&gt;
  &lt;li&gt;一个入口点就是一个程序，它会在容器启动时被执行。如果入口点没有被设置，那么默认的命令会被直接执行。如果入口点被设置，那么默认的命令和它的参数就会作为参数传递给入口点。&lt;/li&gt;
  &lt;li&gt;diff，它能够显示容器中文件系统的所有改动。这些改动包括添加、修改、删除文件和目录：
    &lt;ul&gt;
      &lt;li&gt;A开头的行表示文件被添加。以C开头表示修改，以D开头表示删除。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;深入联合文件系统&quot;&gt;深入联合文件系统&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;联合文件系统由多个层组成。每当对联合文件系统改动一次，改动会被记录到一个新的层中，这个新层放置于所有层的最上面。容器（和用户）访问文件系统所看到的，就是所有这些层的“联合”，或者说是自上而下的观察角度。&lt;/li&gt;
  &lt;li&gt;当你从联合文件系统读取一个文件时，系统会从存在该文件的、最上面的一层中读取。如果文件没有在最顶层被创建或者改动，那么读取操作就会沿着层不断向下找，直到找到存在这个文件的层。&lt;/li&gt;
  &lt;li&gt;文件修改和删除也通过修改最顶层来工作的。当一个文件被删除，一个删除记录就被写入到最顶层，它遮挡了底层该文件的所有版本。当一个文件被修改，修改也被写入到最顶层，它也同样遮挡了底层所有该文件的版本。联合文件系统实际上上会在最顶层添加一个文件来标记一个文件被删除。原始的文件和任何文件副本依旧保留在镜像的其他层中。&lt;/li&gt;
  &lt;li&gt;当只读层（read-only layer）上一个文件被修改了，那么这整个文件会在改动发生之前被复制到最上面的可写层（writable layer）。这对运行时性能和镜像的大小会有负面影响&lt;/li&gt;
  &lt;li&gt;层包含这一层的改动信息和元数据。当你向容器的文件系统提交容器的改动时，你也是以同样的方式保存了最顶层的一个副本。&lt;/li&gt;
  &lt;li&gt;当你提交一层时，一个新的ID会为这一层创建，所有文件改动的副本都会被保存，新层的元数据包含了之前生成的ID，还有更低一层的层ID（父层），还有新层被创建时的执行上下文（execution context）。&lt;/li&gt;
  &lt;li&gt;层ID和元数据形成了一个图，Docker和联合文件系统（UFS）使用这个图来构造镜像。从某些起始层开始，遍历寻找到它们的依赖层，然后这些层以栈的形式构造成镜像。&lt;/li&gt;
  &lt;li&gt;如果你想要复制一个镜像，那么你只需要从现有的镜像创建一个新的标签或仓库。你可以使用docker tag命令来完成。&lt;/li&gt;
  &lt;li&gt;创建容器会创建一个可写层，所有在可写层下面的层都是不可变的，&lt;/li&gt;
  &lt;li&gt;联合文件系统可能有一个层数量的限制。这个限制取决于文件系统，但42层限制在使用AUFS系统的计算机上是非常常见的。&lt;/li&gt;
  &lt;li&gt;docker history命令来查看一个镜像的所有层。输出内容包含以下内容：
    &lt;ul&gt;
      &lt;li&gt;缩写的层ID&lt;/li&gt;
      &lt;li&gt;层的年龄&lt;/li&gt;
      &lt;li&gt;创建容器时的初始命令
  -这一层的全部文件大小&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;层系统使其可以返回到某个镜像历史节点，并且使创建新分支变得更加简单方便。使用层系统来创建分支，这能够同时解决镜像大小和层增长问题。(每当你从同一个镜像创建一个容器，你就潜在地创建了一个新的分支)&lt;/li&gt;
  &lt;li&gt;socker export命令会将扁平的联合文件系统的所有内容导出到标准输出或者一个压缩文件上。输出信息包含了所有从容器角度能够观察到的文件。(如果你需要在容器上下文外使用镜像中的文件系统，这是非常有帮助的。)也可以使用 docker cp 命令来完成这个目标(但如果你想要多个文件，导出整个文件系统可能是更直接的办法)&lt;/li&gt;
  &lt;li&gt;docker import命令会将压缩格式的内容导入到一个新镜像中。import命令能够识别多种压缩或未压缩的压缩文件格式。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">介绍手动的镜像构建</summary></entry><entry><title type="html">Docker小记-安全隔离</title><link href="http://localhost:4000/2020/05/07/Docker%E5%B0%8F%E8%AE%B0-%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB/" rel="alternate" type="text/html" title="Docker小记-安全隔离" /><published>2020-05-07T00:00:00+08:00</published><updated>2020-05-07T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/07/Docker%E5%B0%8F%E8%AE%B0-%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB</id><content type="html" xml:base="http://localhost:4000/2020/05/07/Docker%E5%B0%8F%E8%AE%B0-%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB/">&lt;h2 id=&quot;docker资源分配&quot;&gt;Docker资源分配&lt;/h2&gt;
&lt;h3 id=&quot;内存限制&quot;&gt;内存限制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;docker run或docker create命令上使用-m或–memory选项来设置内存限制&lt;/li&gt;
  &lt;li&gt;这个选项会接受一个值和一个基础单元作为参数。格式如下：
where unit = b,k,m or g
在这个命令中，b表示字节，k表示千字节，m表示兆字节，g表示千兆字节。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d --name mydb \
--m 256m \
--cpu-shares 1024 \
--user nobody \
--cap-drop all \
dockerfile/mariadb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;内存限制并不是内存保留,并不是它保证具体大小的内存是可用的，而是会防止容器使用超出具体大小的内存资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu限制&quot;&gt;CPU限制&lt;/h3&gt;
&lt;h4 id=&quot;cpu-shares&quot;&gt;–cpu-shares&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;–cpu-shares指定容器使用cup资源的相对权重，选项值为一个整数&lt;/li&gt;
  &lt;li&gt;Linux使用这个权重来决定该容器应该占用的CPU时间百分比。这个百分比是相对于所有对容器可用的处理器的CPU周期的总和来计算的。&lt;/li&gt;
  &lt;li&gt;CPU时间少的后果不是失败，而是性能降低
-只有在CPU时间上存在竞争时，它才会被强制执行。如果其他的进程和容器处于空闲中，那么被限制的容器可能会超出CPU资源限制&lt;/li&gt;
  &lt;li&gt;当其他进程需要CPU时，被限制的进程会让出CPU&lt;/li&gt;
  &lt;li&gt;默认配置不会限制容器，因此容器能够使用100%的CPU。
    &lt;h4 id=&quot;cpuset-cpus&quot;&gt;–cpuset-cpus&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;使用 docker run或docker create命令的–cpuset-cpus选项来限制容器只能在某一指定的CPU核集合中执行。值的格式可以是列表或者范围：
    &lt;ul&gt;
      &lt;li&gt;0,1,2 —— 一个列表包含了CPU的前三个核&lt;/li&gt;
      &lt;li&gt;0-2 —— 一个范围包含了CPU的前三个核&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;上下文切换就是从执行一个进程切换到执行另一个进程的任务。这个操作十分昂贵，因此可能对你系统的性能产生显著的影响。确保某些重要的进程不会在同一个CPU核集合中执行能够减少上下文的切换&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;设备的访问权&quot;&gt;设备的访问权&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用–device选项来指定一个设备的集合，这些设备会被挂载进新容器中。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 将在/dev/video0位置的网络摄像头映射到新容器的同一个位置上
docker -it --rm \
--device /dev/viede0:/dev/video0 \
ubuntu:latest ls -al /dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;–device选项的值必须是主机操作系统上的设备文件到新容器中位置的映射&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;设备的访问并不是一种限制，更像是一种资源认证控制&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;跨容器的进程间通信&quot;&gt;跨容器的进程间通信&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IPC(跨进程通信)&lt;/li&gt;
  &lt;li&gt;Docker 为每一个容器创建了一个独立且唯一的 IPC 命名空间&lt;/li&gt;
  &lt;li&gt;IPC命名空间的作用就是防止一个容器中的进程访问主机或者其他容器的内存&lt;/li&gt;
  &lt;li&gt;–ipc选项,创建的新容器的IPC命名空间和另外一个目标容器是一样的
    &lt;ul&gt;
      &lt;li&gt;想要在不同容器中使用共享内存进行通信，需要使用–ipc选项来连接它们的IPC命名空间。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开放内存容器：通过指定–ipc选项的值为host可以和主机运行在同一个命名空间中，实现和运行在主机上的进程进行通信&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linux用户命名空间&quot;&gt;Linux用户命名空间&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Linux用户（USR）命名空间，允许一
一个命名空间中的用户被映射到另一个命名空间的用户上&lt;/li&gt;
  &lt;li&gt;Docker还没有集成USR命名空间。这意味着，如果一个容器的用户ID（数字，不是名字）和主机上的一个用户一样，那么该容器中的用户和主机上的用户拥有相同的主机文件权限&lt;/li&gt;
  &lt;li&gt;容器中的文件系统的改动只会保留在容器的文件系统中，不会影响到主机。但是，这能够影响到卷（volume）。&lt;/li&gt;
  &lt;li&gt;当Docker采用了USR命名空间，能够将主机上的用户ID映射到容器命名空间的用户ID上。&lt;/li&gt;
  &lt;li&gt;如果一个用户能够控制你的Docker后台进程，那么这个用户也能够控制你系统上的root用户。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;设置用户&quot;&gt;设置用户&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-u或–user选项来设置这个run-as用户,支持用户和用户组的名字或ID.下面这个命令将run-as用户设置为nobody：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run--rm --user nobody:defult busybox:latest id
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;如果你设置了run-as用户，那么你就能够完全避免默认用户带来的问题。注意，指定的用户名必须在你使用的镜像中存在
    &lt;ul&gt;
      &lt;li&gt;使用以下命令来获得镜像中的可用用户的列表：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -rm busybox:latest awk -F:‘$0=$1'/etc/passwd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Linux的用户数据库就存储在/etc/passwd文件中。这个命令会读取这个文件，并且获取其中的用户名列表。一旦你找到了你想要使用的用户，你就能够使用这个用户作为run-as用户来启动容器了 - 设置的用户和用户组都不存在于容器中时，ID不会被解析成用户或者用户组名字，但是所有的文件权限会以该用户和用户组存在的情况来进行工作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查看当前用户&quot;&gt;查看当前用户&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;docker inspect子命令能够显示出一个容器的元数据&lt;/li&gt;
  &lt;li&gt;以下命令，如果显示结果空白，那么容器会默认使用root用户来启动。如果结果不为空，要么镜像作者指定了一个默认的run-as用户，
要么就是当你创建这个容器时，你指定了run-as用户
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker inspect --format &quot;&quot; docker_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;docker inspect 返回的元数据仅仅是容器启动时的配置。因此，如果用户被脚本改变了，改动的结果并不会反馈到docker inspect命令的输出上&lt;/li&gt;
  &lt;li&gt;以下两个命令能够获得镜像默认用户的信息,这两个脚本都很谨慎地重置了容器的entrypoint，这确保了命令中跟随在镜像名字后的命令能够被容器执行
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 输出结果：root
docker run --rm --entrypoint &quot;&quot; busybox:latest whoami
// 输出结果：uid=0,git=0,groups=10
docker run --rm --entrypoint &quot;&quot; busybox:latest id
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;用户和卷&quot;&gt;用户和卷&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;卷（volume）中的文件的文件权限在容器中也是有效的。但这也意味着用户ID空间被共享了。主机上的root用户和容器中
的root用户的ID都是0。因此，尽管容器中ID为65534的nobody用户不能够访问主机上root用户创建的文件，但是容器中的root用户可以。&lt;/li&gt;
  &lt;li&gt;除非想要主机的文件能够被容器访问，否则不要将文件以卷的形式挂载到容器上。&lt;/li&gt;
  &lt;li&gt;如果一个进程运行在1001用户下，并且它将日志文件写入到卷中，而另外一个容器中的进程想要以1002用户去访问这个文件，那么文件权限会阻止这个操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;创建更健壮的容器&quot;&gt;创建更健壮的容器&lt;/h2&gt;
&lt;h3 id=&quot;能力操作系统功能的授权&quot;&gt;能力——操作系统功能的授权&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;当创建了一个新容器，在默认情况下，Docker删减了一部分的能力。这么做是为了更进一步地将正在运行的进程和操作系统的管理功能隔离开来。&lt;/li&gt;
  &lt;li&gt;可以通过使用docker create或docker run上的–cap-drop选项来为容器去除能力。&lt;/li&gt;
  &lt;li&gt;–cap-add 选项能够增添能力&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;运行特权容器&quot;&gt;运行特权容器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;当你需要在容器中运行系统管理任务时，你可以授予这些容器访问你计算机的特权&lt;/li&gt;
  &lt;li&gt;特权容器维持它们自己的文件系统和网络隔离，但却拥有对设备和共享内存的全部访问权，还具备全部的系统能力&lt;/li&gt;
  &lt;li&gt;使用docker run或docker create命令的–privileged选项来开启这种模式&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;指定额外的安全选项&quot;&gt;指定额外的安全选项&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;可以使用强制访问控制（MAC——定义访问规则的系统）来取代标准的Linux自主访问控制（文件所有者定义访问规则）。&lt;/li&gt;
  &lt;li&gt;通过docker run或docker create命令上的–security-opt选项来设置这些内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;微调lxc&quot;&gt;微调LXC&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LXC是一个比libcontainer更加成熟的库，且提供了很多与Docker目标背道而驰的额外特性。如果你可以并且想要使用LXC，你可以改变容器供应商，并且利用这些额外的特性&lt;/li&gt;
  &lt;li&gt;为了使用LXC，你需要安装它，并且确保Docker后台进程程序启动时，LXC驱动被允许。当启动Docker后台进程时，使用-
-exec-driver=lxc来使用LXC&lt;/li&gt;
  &lt;li&gt;一旦Docker被配置为LXC，你可以使用docker run或docker create命令的–lxc-conf选项来设置LXC的配置&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">本文介绍管理或限制正在运行的软件的危险性</summary></entry><entry><title type="html">Docker小记-网络</title><link href="http://localhost:4000/2020/05/06/Docker%E5%B0%8F%E8%AE%B0-%E7%BD%91%E7%BB%9C/" rel="alternate" type="text/html" title="Docker小记-网络" /><published>2020-05-06T00:00:00+08:00</published><updated>2020-05-06T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/06/Docker%E5%B0%8F%E8%AE%B0-%E7%BD%91%E7%BB%9C</id><content type="html" xml:base="http://localhost:4000/2020/05/06/Docker%E5%B0%8F%E8%AE%B0-%E7%BD%91%E7%BB%9C/">&lt;h2 id=&quot;docker的网络&quot;&gt;Docker的网络&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Docker使用操作系统的底层特性构建了一个特殊的、可定制的虚拟网络拓扑结构。这个虚拟网络只在安装有Docker的机器上有效，并并且它由主机上的容器和主机所连接的网络之间的路由构成。&lt;/li&gt;
  &lt;li&gt;本地虚拟网络用来提供容器的隔离，Docker使用内核命名空间来创建私有的虚拟接口，但是命名空间本身并不提供网络的隔离。网络暴露或者隔离是通过主机的防火墙规则&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四种网络容器原型&quot;&gt;四种网络容器原型&lt;/h2&gt;
&lt;h3 id=&quot;closed容器&quot;&gt;Closed容器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;docker run 命令后添加–net none 作为参数来创建一个Closed 容器&lt;/li&gt;
  &lt;li&gt;Closed容器中的进程只能够访问本地回环接口&lt;/li&gt;
  &lt;li&gt;如果对网络隔离程度要求非常高，或者程序不需要网络访问权限时，Closed 容器是最好的选择&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bridged容器&quot;&gt;Bridged容器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Bridged容器才是Docker的默认选项，这种原型可定制性最高，并且被认为是最佳实践&lt;/li&gt;
  &lt;li&gt;Bridged容器拥有两个接口，一个是私有的本地回环接口，另外一个私有接口通过网桥连接到主机的其他容器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;joined容器&quot;&gt;Joined容器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Joined容器。这些容器共享一个网络栈，在这种情况下，容器之间没有任何的隔离&lt;/li&gt;
  &lt;li&gt;它们各自维持有不同的文件系统、不同的内存等，但是它们共享了同一个网络组件&lt;/li&gt;
  &lt;li&gt;这种类型的原型通过将某一个容器接口的访问权提供给另外一个新的容器来构建，在这种情况下，接口就类似于共享的数据卷&lt;/li&gt;
  &lt;li&gt;–net选项中容器的值决定了新容器要和哪一个容器进行连接(以下两个命令将会创建两个共享相同网络接口的容器。因为第一个命令创建了一个Closed容器，因此第二个容器只共享那个本地回环接口)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;使用场景
    &lt;ul&gt;
      &lt;li&gt;当你想要不同容器上的程序通过本地回环接口进行通信时&lt;/li&gt;
      &lt;li&gt;当想要监控另外一个容器中某个程序的网络流量时&lt;/li&gt;
      &lt;li&gt;当一个容器中的程序将要改变Joined网络栈，而另外一个程序将要使用那个被改变的网络栈时&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;open容器&quot;&gt;Open容器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;创建：docker run –net host&lt;/li&gt;
  &lt;li&gt;Open容器没有网络容器，并且对主机网络有完全的访问权，包括对重要主机服务的访问权。&lt;/li&gt;
  &lt;li&gt;Open容器没有提供任何隔离，当你没有其他选择时它才应该被考虑&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自定义命名解析&quot;&gt;自定义命名解析&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker run命令有一个–hostname选项，你可以使用这个选项来设置一个新容器的主机名。这个选项会在该容器中的DNS覆盖系统中添加一条记录。这条记录会将提供的主机名映射成该容器的桥接IP地址。&lt;/li&gt;
  &lt;li&gt;-add-host=[]选项能自定义从主机名到IP地址的映射关系,可以设置多个
    &lt;ul&gt;
      &lt;li&gt;可以使用这个功能将特定的主机名映射到一个已知的IP地址上，比如说127.0.0.1，以此来有效地阻止特定的主机名。&lt;/li&gt;
      &lt;li&gt;能为单独的容器提供特定的主机名映射，可能是最细粒度的自定义了。
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm \
--add-host test:10.10.10.255 \ 
alpine:latest \
nslookup test // 解析到10.10.10.255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-dns=[]选项可以被使用多次来设置多个DNS服务器，自定义DNS配置的选项能够用来指定一个或者多个DNS服务器。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm \
--dns 8.8.8.8 \  //设置主DNS服务器
alpine:lastest \
nslookup docker.com // 解析docker.com的ip地址
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;DNS相关的选项——–dns-search=[]，允许你指定一个DNS查找域，这个查找域就像host名的一个默认后缀。当该选项被设置，在查询时，任何不包括已知顶级域名（比如.com或者.net）的主机名会自动加上该后缀名
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm \
--dns-search docker.com \ // 设置查找域
busybox:latest \
nslookup registry.hub // registry.hub.docker.com解析
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;所有的自定义转换关系都保存在容器中的/etc/hosts 文件中。如果你想要看看有哪些覆盖内容，你所要做的就是查找这个文件&lt;/li&gt;
  &lt;li&gt;只有创建容器时，这些选项才会生效。如果一个容器正在运行，你改变了默认值，那么这个容器会保留旧的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;开放对容器的访问&quot;&gt;开放对容器的访问&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker run命令提供了一个-p –publish=[]选项，它能够在主机网络栈上的端口和容器端口之间创建映射关系。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -p 3333:3333
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;docker port命令来查看端口是如何被映射的。port子命令接受一个容器名字或者ID作为参数，并且会输出一个列表，每一行对应一个端口映射&lt;/li&gt;
  &lt;li&gt;–expose选项，它能设置容器想要开发的端口。这个选项能够被设置多次，一个端口设置一次：
    &lt;ul&gt;
      &lt;li&gt;以上命令中的–expose 选项会将端口添加到-P 选项的端口列表中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;禁止跨容器通信: docker -d -icc=false
    &lt;ul&gt;
      &lt;li&gt;当跨容器通信被禁止了，除非被显式允许的流量，否则任何从容器到容器的网络流量都会被主机上的防火墙阻止。&lt;/li&gt;
      &lt;li&gt;当跨容器通信（ICC）被允许时，–expose选项为容器端口到主机端口的映射提供了捷径。&lt;/li&gt;
      &lt;li&gt;当跨容容器通信（ICC）被禁止时，–expose选项成了定义防火墙规则和在网络上显式声明容器接口的一个工具&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;链接&quot;&gt;链接&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d --name mydb \
alpine:latest 

docker run -it --rm \
--link mydb:database \
dockerDemo/ch5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;创建链接时，目标容器必须正在运行。原因非常简单，只有容器正在运行，它们才能维持其IP地址&lt;/li&gt;
  &lt;li&gt;如果某个依赖由于某些原因停止了，则这条链接也会被破坏。(一旦容器被停止或者重启了，那么它将失去IP地址租约并且任何链接到该容器的容器保留的都是过期的链接信息了)&lt;/li&gt;
  &lt;li&gt;链接通过检测目的容器的网络信息（IP地址和开放端口），然后将这些信息注入新容器中。&lt;/li&gt;
  &lt;li&gt;如果跨容器通信被禁止了，Docker会添加特定的防火墙规则来允许被链接的容器间的通信。&lt;/li&gt;
  &lt;li&gt;链接的本质就是静态的、具有方向性和无传递性的依赖&lt;/li&gt;
  &lt;li&gt;创建一条链接会在新容器中添加链接信息，一方面存储在环境变量中，另一方面通过在DNS覆盖系统中添加主机名的映射来将链接信息注入新容器中&lt;/li&gt;
  &lt;li&gt;有多个环境变量由于链接的创建而创建,所有跟某一具体链接相关的变量都会使用该链接别名作为前缀&lt;/li&gt;
  &lt;li&gt;对于每个被链接的容器开放的端口，都会有四个单独的环境变量，并且环境变量的名字包含了对应的开放端口。模式如下：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ALIAS&gt;_PORT_&lt;PORT NUMBER=&quot;&quot;&gt;_&lt;PRO TOCOL=&quot;&quot; TCP=&quot;&quot; or=&quot;&quot; UDP=&quot;&quot;&gt;
&lt;/PRO&gt;&lt;/PORT&gt;&lt;/ALIAS&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ALIAS&gt;_PORT_&lt;PORT NUMBER=&quot;&quot;&gt;_&lt;PRO TOCOL=&quot;&quot; TCP=&quot;&quot; or=&quot;&quot; UDP=&quot;&quot;&gt;_PROTO
&lt;/PRO&gt;&lt;/PORT&gt;&lt;/ALIAS&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ALIAS&gt;_PORT_&lt;PORT NUMBER=&quot;&quot;&gt;_&lt;PRO TOCOL=&quot;&quot; TCP=&quot;&quot; or=&quot;&quot; UDP=&quot;&quot;&gt;_ADDR
&lt;/PRO&gt;&lt;/PORT&gt;&lt;/ALIAS&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ALIAS&gt;_PORT_&lt;PORT NUMBER=&quot;&quot;&gt;_&lt;PRO TOCOL=&quot;&quot; TCP=&quot;&quot; or=&quot;&quot; UDP=&quot;&quot;&gt;_PORT
&lt;/PRO&gt;&lt;/PORT&gt;&lt;/ALIAS&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果能够接受主机上动态或者短暂的端口，那么你可以使用-P –publish-all 选项。这个选项会告诉Docker daemon去创建端口映射关系，将容器的端口都暴露出去。(能够用来通信的端口就是那些已经被目标容器公开的端口)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;修改网桥接口的配置&quot;&gt;修改网桥接口的配置&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;–bip选项（bip是bridge IP的缩写，表示网桥IP），可以设置Docker创建的网桥接口的 IP 地址，也可以使用无类域内路由（CIDR）地址来设置子网的大小。
    &lt;ul&gt;
      &lt;li&gt;假设想要将你的网桥IP地址设置为192.168.0.128，并且只想分配这个子网最后的128个地址。需要将–bip选项的值设置为192.168.0.128/25。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;自定义该网络中的容器的IP地址的范围
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker -d -fixed-cidr “192.168.0.192/26”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;更改Docker网桥的最大传输单元（MTU）(根据协议，以太网接口拥有1500字节的最大数据包大小,这是默认的配置)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker -d -mtu 1200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;可以使用自定义的网桥接口来替代docker0，使用的选项是-b或–bridge&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">Docker使用操作系统的底层特性构建了一个特殊的、可定制的虚拟网络拓扑结构</summary></entry><entry><title type="html">Docker小记-存储卷</title><link href="http://localhost:4000/2020/05/05/Docker%E5%B0%8F%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%8D%B7/" rel="alternate" type="text/html" title="Docker小记-存储卷" /><published>2020-05-05T00:00:00+08:00</published><updated>2020-05-05T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/05/Docker%E5%B0%8F%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%8D%B7</id><content type="html" xml:base="http://localhost:4000/2020/05/05/Docker%E5%B0%8F%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%8D%B7/">&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;存储卷是容器目录树上的挂载点，是一个数据分割、持久化和共享的工具，有一个与容器无关的范围或生命周期。&lt;/li&gt;
  &lt;li&gt;每一个存储卷就是容器目录树的挂载点在主机目录树中的位置，但不同的存储卷类型在主机的位置是不同的
    &lt;ul&gt;
      &lt;li&gt;绑定挂载存储卷使用用户提供的主机目录或文件&lt;/li&gt;
      &lt;li&gt;管理存储卷使用由Docker守护进程控制的位置，被称为Docker管理空间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;镜像适合打包和分发相对静态的文件，如程序；存储卷则持有动态或专门数据。这种区别使得镜像可重用，数据也可以简单分享。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;绑定挂载卷&quot;&gt;绑定挂载卷&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;绑定挂载卷是一种存储卷，指向主机文件系统上用户指定的位置。&lt;/li&gt;
  &lt;li&gt;使用场景
    &lt;ul&gt;
      &lt;li&gt;主机提供的文件或目录需要挂载到容器目录的特定位置&lt;/li&gt;
      &lt;li&gt;将数据分享给运行在容器外的进程，比如主机系统组件&lt;/li&gt;
      &lt;li&gt;比较适合需要使用特殊挂载点的工作站或机器，最好在通用平台或硬件池避免这类特定的绑定。
        &lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;下面的命令将启动一个ApacheHTTP服务器，将主机上的目录绑定挂载在容器服务器的文档根目录中：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d --name web \
-v ~/example-docs:/usr/local/apache2/htdocs \
-p 80:80 \
httpd:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;使用-v选项和位置映射来创建绑定挂载卷。该映射以冒号分隔，映射键（冒号之前的路径）是主机文件系统上的一个绝对路径，该键值（冒号后的路径）是容器中挂载的目标存储位置,必须使用绝对路径指定该位置。&lt;/li&gt;
  &lt;li&gt;当你在一个容器文件系统挂载存储卷，镜像中该位置的内容将被覆盖。&lt;/li&gt;
  &lt;li&gt;如果指定了一个不存在的主机目录，Docker会为你创建相应的目录。但避免这么使用，最好在这个目录上对权限设置有更多的管控。&lt;/li&gt;
  &lt;li&gt;如果用一整个目录绑定挂载到该位置，那么其他文件都将丢失。通过使用一个特定的文件作为存储卷，可以只覆盖或插入单个文件。(需要注意的重点是，文件必须在创建容器之前就存在于主机上。否则Docker会认为你想用一个目录，并在主机上创建它，把它挂载在需要的位置。)&lt;/li&gt;
  &lt;li&gt;将挂载卷和存储卷设为只读权限:你可以通过在存储卷映射规则后追加：ro
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d --name web \
-v ~/example-docs:/usr/local/apache2/htdocs:ro \
-p 80:80 \
httpd:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;无法跨主机移植：将可移植容器绑定到特定主机的文件系统，如果容器的定义取决于主机文件系统特定位置上的内容，无论所在位置的内容可用或不可用，该定义无法跨主机移植&lt;/li&gt;
  &lt;li&gt;创造了与其他容器发生冲突的机会&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;docker管理卷&quot;&gt;Docker管理卷&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;管理卷创建：执行docker run使用-v选项（或–volume）,指定容器目录树中的挂载点，Docker守护程序会在主机文件系统中创建存储卷，并由Docke管理，&lt;/li&gt;
  &lt;li&gt;获取容器挂载点的列表，以及在主机目录树中的相应路径的方法：
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker inspect -f ＂＂ docker-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;inspect子命令将输出容器挂载点的列表，以及在主机目录树中的相应路径。输出将是： {＂/var/lib/cassandra/data＂:＂/mnt/sda1/var/lib/docker/vfs/dir/632fa59c…＂} 键是容器中的挂载点，键值是主机文件系统上的目录位置&lt;/li&gt;
  &lt;li&gt;区分存储卷最好的方法是为每个管理卷定义一个容器。这样可以很具体地了解用了哪些存储卷还可以帮助你删除特定的存储卷。&lt;/li&gt;
  &lt;li&gt;运行带有-v选项的docker rm命令将试图删除目标容器中引用的任何管理卷。任何有其他容器引用的管理卷将被忽略&lt;/li&gt;
  &lt;li&gt;如果删除每一个已引用管理卷的容器，但没有使用-v标志，就会产生孤立卷。移除孤立卷，需要一系列手工操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;volumes-from共享卷&quot;&gt;volumes-from共享卷&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;–volumes-from，可将卷从一个或多个容器复制到新的容器中。可设定多次，可指定多个源容器。&lt;/li&gt;
  &lt;li&gt;复制卷始终具有相同的挂载点，且具有相同的卷定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;存储卷的高级容器模式&quot;&gt;存储卷的高级容器模式&lt;/h2&gt;
&lt;h3 id=&quot;卷容器模式&quot;&gt;卷容器模式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;这是一个只提供卷的句柄的容器。卷容器并不需要运行，因为停止时容器仍能保证存储卷的引用&lt;/li&gt;
  &lt;li&gt;当创建新容器时，使用已停止的容器作为–volumes-from标志来源。
    &lt;h3 id=&quot;数据打包的存储卷容器&quot;&gt;数据打包的存储卷容器&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;数据打包的卷容器将镜像中的静态内容复制到其定义的存储卷。这些容器可用于分发关键架构信息，如配置，密钥材料和代码。&lt;/li&gt;
  &lt;li&gt;使用存储卷，你可以注入不同的行为到容器中，而无需修改其镜像。&lt;/li&gt;
  &lt;li&gt;对于手动构建的镜像中包含的可用数据，需要复制出来，可通过运行和定义存储卷，并在容器启动时执行cp命令：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 复制镜像内容到一个存储卷
docker run --name dpvc \
-v /config \
demo/ch4 /bin/sh -c 'cp /packed/* /config/'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Oden Su</name></author><summary type="html">存储卷持有动态或专门数据，使得镜像可重用，数据也可以简单分享。</summary></entry><entry><title type="html">Docker小记-镜像</title><link href="http://localhost:4000/2020/05/04/Docker%E5%B0%8F%E8%AE%B0-%E9%95%9C%E5%83%8F/" rel="alternate" type="text/html" title="Docker小记-镜像" /><published>2020-05-04T00:00:00+08:00</published><updated>2020-05-04T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/04/Docker%E5%B0%8F%E8%AE%B0-%E9%95%9C%E5%83%8F</id><content type="html" xml:base="http://localhost:4000/2020/05/04/Docker%E5%B0%8F%E8%AE%B0-%E9%95%9C%E5%83%8F/">&lt;h2 id=&quot;镜像&quot;&gt;镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker镜像：是一个容器中运行程序的所有文件的捆绑快照。&lt;/li&gt;
  &lt;li&gt;镜像包含了创建容器所需的文件和镜像元数据。该元数据包含关于镜像之间的关联信息、命令历史、暴露的端口、卷的定义等。&lt;/li&gt;
  &lt;li&gt;镜像维护着父/子依赖关系。在这些依赖关系中，从父层构建形成新的一层。容器中的文件是镜像所创建容器的所有层合集。&lt;/li&gt;
  &lt;li&gt;镜像可以与任何其他镜像有依赖关系，包括不同的所有者提供的不同仓库的镜像。&lt;/li&gt;
  &lt;li&gt;容器中正在运行的程序对镜像分层一无所知，仿佛该操作不是在容器中或操作镜像上运行的。从容器的角度看，它具有由镜像所提供文件的独占副本。(这就是所谓Union文件系统。Union文件系统是创建有效文件系统隔离极为关键的一套工具)&lt;/li&gt;
  &lt;li&gt;公共层仅需安装一次。如果想安装任何数目的镜像，它们都依赖于公共层，即公共层以及它的所有父层，都只需被下载或安装一次&lt;/li&gt;
  &lt;li&gt;一个标签只能在一个仓库中被应用到单个镜像，但一个镜像可以有多个标签。&lt;/li&gt;
  &lt;li&gt;仓库名由该镜像所在的主机、拥有该镜像的用户账户和一个简短的名称组成。&lt;/li&gt;
  &lt;li&gt;运行docker images -a将显示，包括&lt;none&gt;多个仓库的列表&lt;/none&gt;&lt;/li&gt;
  &lt;li&gt;Linux内核提供了MNT系统命名空间。当Docker创建一个容器，这个新的容器会有自己的MNT命名空间，以及为镜像创建新的挂载点。最后，chroot通过容器上下文来构建镜像的根文件系统。这可以防止运行于容器内的任何程序与主机系统的其他部分有所关联。chroot和MNT命名空间是常见的容器技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;镜像文件的导出及导入&quot;&gt;镜像文件的导出及导入&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker save命令把该镜像保存到文件,创建的是TAR归档文件。如果省略-o标志，生成的文件将被传输到终端。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker save -o myfile.tar nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;docker load命令，加载镜像。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker load -i myfile.tar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;从dockerfile安装镜像&quot;&gt;从DockerFile安装镜像&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Dockerfile是Docker用来描述新镜像构建步骤的脚本。这个文件会和作者想要放入镜像的软件一起发布。&lt;/li&gt;
  &lt;li&gt;docker build 命令的-t选项的值设置成要安装镜像的仓库。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build -t test_ch3/dockerfile:latest ch3_dockerfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">docker镜像是一个容器中运行程序的所有文件的捆绑快照</summary></entry><entry><title type="html">Docker小记-Docker中运行软件</title><link href="http://localhost:4000/2020/05/02/Docker%E5%B0%8F%E8%AE%B0-Docker%E4%B8%AD%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6/" rel="alternate" type="text/html" title="Docker小记-Docker中运行软件" /><published>2020-05-02T00:00:00+08:00</published><updated>2020-05-02T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/02/Docker%E5%B0%8F%E8%AE%B0-Docker%E4%B8%AD%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6</id><content type="html" xml:base="http://localhost:4000/2020/05/02/Docker%E5%B0%8F%E8%AE%B0-Docker%E4%B8%AD%E8%BF%90%E8%A1%8C%E8%BD%AF%E4%BB%B6/">&lt;h2 id=&quot;docker命令&quot;&gt;Docker命令&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;docker help &lt;command /&gt;:显示Docker命令行工具的基本语法&lt;/li&gt;
  &lt;li&gt;docker ps：显示每个运行的容器&lt;/li&gt;
  &lt;li&gt;docker logs &lt;dockerName&gt;: 后接docker名称或id显示日志
&lt;/dockerName&gt;    &lt;ul&gt;
      &lt;li&gt;写入的日志将持久化保存、持续增长，只要该容器还存在。长期持久性会成为长期进程的一个问题。一个更好的方式是，使用存储卷来处理日志数据&lt;/li&gt;
      &lt;li&gt;docker logs命令有一个标志，–follow或-f，用来显示整个日志，然后将继续监视和更新日志的显示，不放过任何日志中的变化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;docker restart &lt;dockerName&gt;&lt;/dockerName&gt;&lt;/li&gt;
  &lt;li&gt;docker stop &lt;dockerName&gt;&lt;/dockerName&gt;&lt;/li&gt;
  &lt;li&gt;docker exec：在运行的容器中运行额外的进程。&lt;/li&gt;
  &lt;li&gt;docker create：和docker run很类似，主要区别在于该容器是被停止状态创建&lt;/li&gt;
  &lt;li&gt;docker rename：重命名该容器&lt;/li&gt;
  &lt;li&gt;docker top：显示的是主机为每一个容器中的进程所分配的 PID&lt;/li&gt;
  &lt;li&gt;docker rm: 删除容器，可以通过在命令中指定–rm来避免清理工作的负担。这样做，当容器进入退出状态时，就会被自动删除。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec web ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;守护式容器&quot;&gt;守护式容器&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;适合那些在后台静默运行的程序，这类程序被称为守护程序。守护程序通常通过网络或其他通信工具和其他程序或人进行交互。&lt;/li&gt;
  &lt;li&gt;在后台运行容器的守护程序，使用–detach标志或其缩写形式-d。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --detach --name web nginx:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;交互式容器&quot;&gt;交互式容器&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;使用–interactive（或-i）和–tty（或-t）
    &lt;ul&gt;
      &lt;li&gt;–interactive选项告诉Docker保持标准输入流（stdin，标准输入）对容器开放，即使容器没有终端连接。&lt;/li&gt;
      &lt;li&gt;–tty 选项告诉 Docker 为容器分配一个虚拟终端，这将允许你发信号给容器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;启动容器后，得让程序在容器内运行起来。在这种情况下，运行一个叫作sh的shell程序。这样就可以在容器内运行任何程序&lt;/li&gt;
  &lt;li&gt;输入exit来关闭这个互动容器。这将终止shell程序，并停止该容器。&lt;/li&gt;
  &lt;li&gt;按住【Ctrl】（或【Control】）键，然后按【P】键，再按【Q】键，之后就会返回到主机的shell且该容器继续运行。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 创建虚拟终端并绑定标准输入
docker run --interactive --tty 
-- link web:web \
--name web_test \
busybox:latest /bin/sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pid命名空间&quot;&gt;PID命名空间&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;每一个运行的程序或进程，在Linux机器都有一个唯一编号，叫作进程标识符（PID）。&lt;/li&gt;
  &lt;li&gt;每个命名空间拥有一套完整的PID,为每个容器创建一个PID命名空间是Docker的关键特征。&lt;/li&gt;
  &lt;li&gt;从进程的一个命名空间角度来看，PID1可能是指像runit或supervisord这样的init系统进程。在不同的命名空间中，PID1可能是指诸如bash的shell命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;只读文件系统&quot;&gt;只读文件系统&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;–read-only&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d --name wp --read-only wordpress:4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;docker inspect命令将显示Docker为该容器保留的所有元数据（一个JSON文件）。格式选项会改变元数据。除了该容器的运行状态，下例中其会滤除元数据的所有字段。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker inspect --format ＂＂ wp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;环境变量的注入&quot;&gt;环境变量的注入&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;-env标志或-e缩写，可用于注入任何环境变量。如果变量已经由镜像或Docker设置，则该值将被覆盖&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自动重启容器&quot;&gt;自动重启容器&lt;/h2&gt;
&lt;h3 id=&quot;restart&quot;&gt;restart&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-restart 标志，就可以通知Docker完成以下操作：
    &lt;ul&gt;
      &lt;li&gt;从不重新启动（默认）&lt;/li&gt;
      &lt;li&gt;检测到故障时尝试重新启动
  -当检测到故障时，在一段预预定的时间后重新开始尝试重启&lt;/li&gt;
      &lt;li&gt;不管任何条件，始终重新启动容器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;回退策略决定了连续尝试重新启动所需要的时间间隔。指数回退策略会将花在前一次等待连续尝试的时间加倍。例如，如果第一次容器重新启动Docker需要等待1秒钟，然后第二次尝试将等待2秒，第三次等待4秒，第四次等待8秒，以此类推。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d --name backoff-detector --restart always wp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;initsupervisor&quot;&gt;init、supervisor&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;init或supervisor进程，用于启动和维护其他程序状态。在Linux系统中，PID #1是init进程。它启动所有其他系统进程，并在出现意外故障时重新启动它们。容器中使用类似的模式来启动和管理进程，是一个常见的做法。&lt;/li&gt;
  &lt;li&gt;容器中的supervisor进程用来保持容器始终运行，即使目标进程（如一个web服务器），出现故障并重新启动。一个容器中可能有多个这样程序，最流行的包括init、systemd、runit、upstart和supervisord&lt;/li&gt;
  &lt;li&gt;使用init或supervisor程序的一个常见替代方法是使用一个启动脚本，该脚本至少会检查软件成功启动的先决条件。这些脚本有时会用作容器的默认命令&lt;/li&gt;
  &lt;li&gt;使用–entrypoint标志来运行指定程序，并传递参数
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --entrypoint=&quot;cat&quot; \  // 使用cat作为容器执行的入口
nginx:latest /entrypoint.sh      // 将/entrypoint.sh作为cat命令的参数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">介绍在容器中运行软件及相关的命令</summary></entry><entry><title type="html">Docker小记-基础概念</title><link href="http://localhost:4000/2020/05/01/Docker%E5%B0%8F%E8%AE%B0-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" rel="alternate" type="text/html" title="Docker小记-基础概念" /><published>2020-05-01T00:00:00+08:00</published><updated>2020-05-01T00:00:00+08:00</updated><id>http://localhost:4000/2020/05/01/Docker%E5%B0%8F%E8%AE%B0-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5</id><content type="html" xml:base="http://localhost:4000/2020/05/01/Docker%E5%B0%8F%E8%AE%B0-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">&lt;p&gt;Docker包括一个命令行程序、一个后台守护进程，以及一组远程服务。它解决了常见的软件问题，并简化了安装、运行、发布和删除软件。这一切能够实现是通过使用一项UNIX技术，称为容器。
Docker不提供容器技术，它隐藏了直接和容器软件打交道的复杂性。&lt;/p&gt;

&lt;h2 id=&quot;docker容器与虚拟机的区别&quot;&gt;Docker容器与虚拟机的区别&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;虚拟机：提供虚拟的硬件，可安装一个操作系统和其他程序。它们需要很长的时间（通常以分钟计）来创建，也需要显著的资源开销，因为它们除了要执行你需要的软件，还得运行整个操作系统的副本。（操作系统是所有用户程序和该计算机上运行的硬件之间的接口）&lt;/li&gt;
  &lt;li&gt;Docker容器:运行在Docker容器中的程序接口和主机的 Linux 内核直接打交道。因为容器中运行的程序和计算机的操作系统之间没有额外的中间层，没有资源被冗余软件的运行或虚拟硬件的模拟而浪费掉。
    &lt;h2 id=&quot;docker的运行&quot;&gt;Docker的运行&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;运行Docker可以认为是在用户空间运行着两个程序
    &lt;ul&gt;
      &lt;li&gt;Docker守护进程。这个进程应始终处于运行状态。&lt;/li&gt;
      &lt;li&gt;Docker CLI，它是与用户交互的Docker程序。如果要启动、停止或安装软件，可使用Docker CLI执行相应的命令。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;运行的容器是以Docker守护程序的子进程运行，封装在容器中，并授权其在自身用户空间的存储子空间中运行。在容器中运行的程序，只能访问属于自己的该容器审定过的内存空间和资源。&lt;/li&gt;
  &lt;li&gt;容器的运行状态直接和容器内单次运行的程序状态关联。如果程序在运转，容器运行；如果程序停止，该容器被停止。重新启动容器会再次运行该程序。&lt;/li&gt;
  &lt;li&gt;Docker可原生运行在Linux上，在OS X和Windows环境
中通过单独的虚拟机也可运行。(在OS X和Windows,Docker使用一个小而单一的虚拟机来运行所有的容器。)
    &lt;h2 id=&quot;docker的优势&quot;&gt;Docker的优势&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;简化软件安装及轻松管理依赖关系&lt;/li&gt;
  &lt;li&gt;提高可移植性：Docker改善了每个程序的可移植性，无论它用什么语言编写，为什么操作系统而设计，或是在什么样的运行环境下。&lt;/li&gt;
  &lt;li&gt;提高安全性：容器限制了一个程序对其他程序带来的影响范围、可访问的数据和系统资源的影响范围&lt;/li&gt;
  &lt;li&gt;保持机器整洁:当你要删除软件时，你只要告诉Docker要删除哪个软件。没有散落在外的文件，因为它们都被封装在容器中。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">Docker包括一个命令行程序、一个后台守护进程，以及一组远程服务。它解决了常见的软件问题，并简化了安装、运行、发布和删除软件。这一切能够实现是通过使用一项UNIX技术，称为容器。 Docker不提供容器技术，它隐藏了直接和容器软件打交道的复杂性。</summary></entry><entry><title type="html">MongoDB笔记</title><link href="http://localhost:4000/2019/09/30/MongoDB%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="MongoDB笔记" /><published>2019-09-30T00:00:00+08:00</published><updated>2019-09-30T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/30/MongoDB%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/2019/09/30/MongoDB%E7%AC%94%E8%AE%B0/">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;非关系型数据库
    &lt;ul&gt;
      &lt;li&gt;键值数据库：redis、flare：极高的读写性能，用于处理大量数据的高访问负载，主要用作缓存&lt;/li&gt;
      &lt;li&gt;文档型数据库：MongoDB：满足海量数据存储，对字段要求不严格，不需要预先定义表结构，并发写入速度高&lt;/li&gt;
      &lt;li&gt;列存储数据库：Hbase：查找速度快，可拓展性强&lt;/li&gt;
      &lt;li&gt;图数据库：InfoGrid、Neo4J：适用于关系图谱&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mongodb快速入门&quot;&gt;MongoDB快速入门&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;概念：集合Collection-文档Document-字段Field&lt;/li&gt;
  &lt;li&gt;_id:Object Id,由时间、机器码、进程pid和自增计数构成，始终递增绝不重复；前八位字符转换为十进制就是时间戳&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;插入&quot;&gt;插入&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').insertOne({&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;:17})

db.getCollection('xx').insertMany([
{&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;:17},
{&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;:18}
])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查询&quot;&gt;查询&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').find()
db.getCollection('xx').find({'字段1':'值1','字段2':'值2'})
db.getCollection('xx').find({'age':{'$get':25,'$lte':28})

// 限定返回，只可能全1或全1
db.getCollection('xx').find({'age':{'$get':25,'$lte':28}, {'name':1,'age':1})

// 排序 1正序 -1倒序
db.getCollection('xx').find({'age':{'$get':25,'$lte':28}).sort({'字段名':-1})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;修改&quot;&gt;修改&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').updateOne({'name':'x'}, {'$set':{'address':'xx'}})
db.getCollection('xx').updateMany({'name':'x'}, {'$set':{'address':'xx'}})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;删除&quot;&gt;删除&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 返回的数据中，acknowledged为true表示删除成功，deletedCount表示删除的条数
db.getCollection('xx').deleteOne({'name':'x'})
db.getCollection('xx').deleteMany({'name':'x'})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据去重&quot;&gt;数据去重&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').distinct('age')
db.getCollection('xx').distinct('age',{'age':{'$gte':13}})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;mongodb高级语法&quot;&gt;MongoDB高级语法&lt;/h2&gt;
&lt;h3 id=&quot;andor&quot;&gt;AND\OR&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').find('$and':[{'age':{'$gte':3}}, {'sex':'男'}])
db.getCollection('xx').find('$or':[{'age':{'$gte':3}}, {'sex':'男'}])
db.getCollection('xx').find('$and':[
'$or':[{'age':{'$gte':3}}, {'sex':'男'}], 
'$or':[{'age':{'$gte':3}}, {'sex':'男'}]
])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数组中查询&quot;&gt;数组中查询&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;查询数组中包含和不包含，和普通的字段查询相同&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 查询数组长度：$size
db.getCollection('xx').find({'price':{'$size':2})
// 查询数组中第1个数据
db.getCollection('xx').find({'size.0':'S')
db.getCollection('xx').find({'price.0':'$get':500)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;聚合查询&quot;&gt;聚合查询&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;db.getCollection(‘xx’).aggregate([阶段1，阶段2，阶段3，…])&lt;/li&gt;
  &lt;li&gt;$match:筛选，$project:字段相关，$group:分组相关
    &lt;h4 id=&quot;match&quot;&gt;$match&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection(&quot;sensor_property_records&quot;).aggregate([
	{
        $match: {
        	&quot;device_sn&quot; : {
        	    &quot;$in&quot; : [
        	        &quot;2CF7F15000100102&quot;, 
        	        &quot;2CF7F15000100105&quot;
        	    ]
        	}, 
        	&quot;ctime&quot; : {
        	    &quot;$gte&quot; : 1564452038000.0, 
        	    &quot;$lte&quot; : 1565056838000.0
        	}
       }
	},
	{
    	$sort: {ctime:-1}, 
    },
    {
    	$limit:100
    }
]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;project&quot;&gt;$project&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;$project,如果一个字段不是0或1，而是字符串，则直接输出该字符串；如果是$+已有字段名，则复制该字段的值&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 返回特定字段，并增加一个新字段
db.getCollection('xx').aggregate([{'$match':{'age':{'$get':25,'$lte':28}}},{'$project':{'sex':1,'age':1, 'hello':'word'}}])

db.getCollection('xx').aggregate([{'$match':{'age':{'$get':25,'$lte':28}}},{'$project':{'sex':1,'age':1, 'hello':'$age'}}])

db.getCollection('xx').aggregate([{'$match':{'age':{'$get':25,'$lte':28}}},{'$project':{'sex':1,'age':'this is age'}])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;用于抽取嵌套字段&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').aggregate([$project])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;$literal用于显示特殊字符&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').aggregate([{'$project':{'hello':{'$literal':'$normalstring'}}}])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;group&quot;&gt;$group&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;$sum,$avg,$max,$min&lt;/li&gt;
  &lt;li&gt;去重&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 返回记录
db.getCollection('xx').aggregate([{'$group':{'_id':'$name'}}])

db.getCollection('xx').aggregate([{'$group':{'_id':'$name',
'max_score':{'$max':'$字段名'}，
'sum_score':{'$sum':'$字段名'}，
}}])

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;$sum可以使用数字1，返回统计条数&lt;/li&gt;
  &lt;li&gt;$last:取最后一条数据，$first：取最新的一条数据&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').aggregate([{'$group':{'_id':'$name',
'date':{'$last':'$date'}，
'score':{'$last':'$score'}，
}}])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;unwind&quot;&gt;$unwind&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;拆分数组，将包含数组的记录拆分为多条记录，每条中拥有数组的一个元素&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').aggregate([{'$unwind':'$size}])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;联集查询&quot;&gt;联集查询&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.getCollection('xx').aggregate([
{
  '$lookup':{
    'from':'被查集合名'，
    'localField':'主集合字段'，
    'foreignField':'被查集合字段'，
    'as':'保存查询结果的字段名' // 嵌入式文档
    }  
}])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;安全及性能&quot;&gt;安全及性能&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;批量插入&lt;/li&gt;
  &lt;li&gt;索引，空间换时间&lt;/li&gt;
  &lt;li&gt;以插入数据代替更新&lt;/li&gt;
  &lt;li&gt;冗余信息&lt;/li&gt;
  &lt;li&gt;字符串比较数字，左侧补0&lt;/li&gt;
  &lt;li&gt;admin数据库是MongoDB自带的数据库&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Oden Su</name></author><summary type="html">MongoDB笔记</summary></entry></feed>